"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebsocketBuilder = void 0;
var websocket_event_1 = require("./websocket_event");
var websocket_1 = require("./websocket");
/**
 * Builder for websockets.
 */
var WebsocketBuilder = /** @class */ (function () {
    /**
     * Creates a new WebsocketBuilder.
     *
     * @param url the url to connect to
     */
    function WebsocketBuilder(url) {
        this._url = url;
    }
    Object.defineProperty(WebsocketBuilder.prototype, "url", {
        /**
         * Getter for the url.
         *
         * @returns the url
         */
        get: function () {
            return this._url;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Adds protocols to the websocket. Subsequent calls to this method will override the previously set protocols.
     *
     * @param protocols the protocols to add
     */
    WebsocketBuilder.prototype.withProtocols = function (protocols) {
        this._protocols = protocols;
        return this;
    };
    Object.defineProperty(WebsocketBuilder.prototype, "protocols", {
        /**
         * Getter for the protocols.
         *
         * @returns the protocols, undefined if no protocols have been set
         */
        get: function () {
            return this._protocols;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets the maximum number of retries before giving up. No limit if undefined.
     *
     * @param maxRetries the maximum number of retries before giving up
     */
    WebsocketBuilder.prototype.withMaxRetries = function (maxRetries) {
        var _a;
        this._options = __assign(__assign({}, this._options), { retry: __assign(__assign({}, (_a = this._options) === null || _a === void 0 ? void 0 : _a.retry), { maxRetries: maxRetries }) });
        return this;
    };
    Object.defineProperty(WebsocketBuilder.prototype, "maxRetries", {
        /**
         * Getter for the maximum number of retries before giving up.
         *
         * @returns the maximum number of retries before giving up, undefined if no maximum has been set
         */
        get: function () {
            var _a, _b;
            return (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.maxRetries;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.
     *
     * @param instantReconnect wether to reconnect immediately after a connection has been lost
     */
    WebsocketBuilder.prototype.withInstantReconnect = function (instantReconnect) {
        var _a;
        this._options = __assign(__assign({}, this._options), { retry: __assign(__assign({}, (_a = this._options) === null || _a === void 0 ? void 0 : _a.retry), { instantReconnect: instantReconnect }) });
        return this;
    };
    Object.defineProperty(WebsocketBuilder.prototype, "instantReconnect", {
        /**
         * Getter for wether to reconnect immediately after a connection has been lost, ignoring the backoff strategy for the first retry.
         *
         * @returns wether to reconnect immediately after a connection has been lost, undefined if no value has been set
         */
        get: function () {
            var _a, _b;
            return (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.instantReconnect;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Adds a backoff to the websocket. Subsequent calls to this method will override the previously set backoff.
     *
     * @param backoff the backoff to add
     */
    WebsocketBuilder.prototype.withBackoff = function (backoff) {
        var _a;
        this._options = __assign(__assign({}, this._options), { retry: __assign(__assign({}, (_a = this._options) === null || _a === void 0 ? void 0 : _a.retry), { backoff: backoff }) });
        return this;
    };
    Object.defineProperty(WebsocketBuilder.prototype, "backoff", {
        /**
         * Getter for the backoff.
         *
         * @returns the backoff, undefined if no backoff has been set
         */
        get: function () {
            var _a, _b;
            return (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.backoff;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Adds a buffer to the websocket. Subsequent calls to this method will override the previously set buffer.
     *
     * @param buffer the buffer to add
     */
    WebsocketBuilder.prototype.withBuffer = function (buffer) {
        this._options = __assign(__assign({}, this._options), { buffer: buffer });
        return this;
    };
    Object.defineProperty(WebsocketBuilder.prototype, "buffer", {
        /**
         * Getter for the buffer.
         *
         * @returns the buffer, undefined if no buffer has been set
         */
        get: function () {
            var _a;
            return (_a = this._options) === null || _a === void 0 ? void 0 : _a.buffer;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Adds an 'open' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
     * called in the order they were added.
     *
     * @param listener the listener to add
     * @param options the listener options
     */
    WebsocketBuilder.prototype.onOpen = function (listener, options) {
        this.addListener(websocket_event_1.WebsocketEvent.open, listener, options);
        return this;
    };
    /**
     * Adds an 'close' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
     * called in the order they were added.
     *
     * @param listener the listener to add
     * @param options the listener options
     */
    WebsocketBuilder.prototype.onClose = function (listener, options) {
        this.addListener(websocket_event_1.WebsocketEvent.close, listener, options);
        return this;
    };
    /**
     * Adds an 'error' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
     * called in the order they were added.
     *
     * @param listener the listener to add
     * @param options the listener options
     */
    WebsocketBuilder.prototype.onError = function (listener, options) {
        this.addListener(websocket_event_1.WebsocketEvent.error, listener, options);
        return this;
    };
    /**
     * Adds an 'message' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
     * called in the order they were added.
     *
     * @param listener the listener to add
     * @param options the listener options
     */
    WebsocketBuilder.prototype.onMessage = function (listener, options) {
        this.addListener(websocket_event_1.WebsocketEvent.message, listener, options);
        return this;
    };
    /**
     * Adds an 'retry' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
     * called in the order they were added.
     *
     * @param listener the listener to add
     * @param options the listener options
     */
    WebsocketBuilder.prototype.onRetry = function (listener, options) {
        this.addListener(websocket_event_1.WebsocketEvent.retry, listener, options);
        return this;
    };
    /**
     * Adds an 'reconnect' event listener to the websocket. Subsequent calls to this method will add additional listeners that will be
     * called in the order they were added.
     *
     * @param listener the listener to add
     * @param options the listener options
     */
    WebsocketBuilder.prototype.onReconnect = function (listener, options) {
        this.addListener(websocket_event_1.WebsocketEvent.reconnect, listener, options);
        return this;
    };
    /**
     * Builds the websocket.
     *
     * @return a new websocket, with the set options
     */
    WebsocketBuilder.prototype.build = function () {
        return new websocket_1.Websocket(this._url, this._protocols, this._options); // instantiate the websocket with the set options
    };
    /**
     * Adds an event listener to the options.
     *
     * @param event the event to add the listener to
     * @param listener the listener to add
     * @param options the listener options
     */
    WebsocketBuilder.prototype.addListener = function (event, listener, options) {
        var _a;
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
        this._options = __assign(__assign({}, this._options), { listeners: (_a = {
                    open: (_d = (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.listeners) === null || _c === void 0 ? void 0 : _c.open) !== null && _d !== void 0 ? _d : [],
                    close: (_g = (_f = (_e = this._options) === null || _e === void 0 ? void 0 : _e.listeners) === null || _f === void 0 ? void 0 : _f.close) !== null && _g !== void 0 ? _g : [],
                    error: (_k = (_j = (_h = this._options) === null || _h === void 0 ? void 0 : _h.listeners) === null || _j === void 0 ? void 0 : _j.error) !== null && _k !== void 0 ? _k : [],
                    message: (_o = (_m = (_l = this._options) === null || _l === void 0 ? void 0 : _l.listeners) === null || _m === void 0 ? void 0 : _m.message) !== null && _o !== void 0 ? _o : [],
                    retry: (_r = (_q = (_p = this._options) === null || _p === void 0 ? void 0 : _p.listeners) === null || _q === void 0 ? void 0 : _q.retry) !== null && _r !== void 0 ? _r : [],
                    reconnect: (_u = (_t = (_s = this._options) === null || _s === void 0 ? void 0 : _s.listeners) === null || _t === void 0 ? void 0 : _t.reconnect) !== null && _u !== void 0 ? _u : []
                },
                _a[event] = __spreadArray(__spreadArray([], ((_x = (_w = (_v = this._options) === null || _v === void 0 ? void 0 : _v.listeners) === null || _w === void 0 ? void 0 : _w[event]) !== null && _x !== void 0 ? _x : []), true), [
                    { listener: listener, options: options },
                ], false),
                _a) });
        return this;
    };
    return WebsocketBuilder;
}());
exports.WebsocketBuilder = WebsocketBuilder;
//# sourceMappingURL=websocket_builder.js.map